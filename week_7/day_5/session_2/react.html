<!DOCTYPE html>
<html>

<head>
    <title>Exercise 3</title>

</head>

<body>
   <div id="root"></div>
   

    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>

    <script type="text/babel">
    // Component and Props


    // omponents let you split the UI into independent, reusable pieces, and think about each piece in isolation. This page provides an introduction to the idea of components.
    // Conceptually, components are like JavaScript functions
    // They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.
    // Function and class Components

    // This function is a valid React component because it accepts a single “props” (which stands for properties) 
    // function Welcome(props){
    //     return <h1>Hello, {props.name}</h1>
    // }
    // const elem = 'Sudhir singh'


    // You can also use an ES6 class to define a component
    //in class we have use this.props.name always
    // class Welcome extends React.Component{
    //     render(){
    //         return <h1>Hello, {this.props.name}</h1>
    //     }
    // }
    // const elem = <Welcome name="Sudhir Singh" />;

    // Let’s recap what happens in this example:
    // We call ReactDOM.render() with the <Welcome name="Sudhir Singh" /> elem.
    // React calls the Welcome component with {name: 'Sudhir'} as the props.
    // Our Welcome component returns a <h1>Hello, Sudhir</h1> element as the result.
    // React DOM efficiently updates the DOM to match <h1>Hello, Sudhir</h1>.
    // Note: Always start component names with a capital letter.
    // if we provide component in lowercase it will treat as DOM tags
    
    //  we can create an App component that renders Welcome many times:
    // Extracting Components
    // Don’t be afraid to split components into smaller components.

    // let's make the comment component
    // function Avatar (props) {
    //     return (
    //         <img src={props.image} />
    //     )
    // }
    // const elem = 'http://www.imgworlds.com/wp-content/uploads/2015/11/ttd-marvel-tonysskydesc.jpg'
    // ReactDOM.render(<Avatar image={elem}/>, document.getElementById('root'))
    
    //Props are Read-Only
    // Whether you declare a component as a function or a class, it must never modify its own props
    
    // State and LifeCycle
    // make clock timer to enhance ypur state nad lifecyle

    // function Clock(props){
    //     return (
    //         <div>
    //             <h1>Hello, Sudhir, Are you excited to make timer</h1>
    //             <h2>It is  {props.date.toLocaleTimeString()}</h2>
    //         </div>
    //     );
    // }

    // function tick() {
    //     ReactDOM.render(
    //         <Clock date={new Date()}/>,
    //         document.getElementById('root')
    //     )
    // }
    // setInterval(tick, 1000)

    // State is similar to props, but it is private and fully controlled by the component.
    // Add state to class
    // Converting a function to class
    // convert a function like Clock in five steps
    // 1.Create an ES6 class with the same name, that extends React.Component
    // 2.Add a single empty method to it called render()
    // 3.Move the body  of the function into the render() body
    // 4.Replace props with this.props in render body
    // 5.Delete the remaining empty function declaration

    // class Clock extends React.Component{
    //     render() {
    //         return (
    //             <div>
    //                 <h1>Hello, Sudhir, Are you excited to make timer</h1>
    //                 <h2>It is  {this.props.date.toLocaleTimeString()}</h2>
    //             </div>
    //         )
    //     }
    // }

    // function tick(){
    //     ReactDOM.render(
    //         <Clock date = {new Date()}/>,
    //         document.getElementById('root')
    //     )
    // }
    // setInterval(tick, 1000)

    // what's happening in above code
    // render method will be called each time an update happens,
    //  but as long as we render <Clock /> into the same DOM node, only a single instance of the Clock class will be used

    // let's add state and lifecycle
    // Adding Local State to calss
    // We will move the date from props to state in three steps:
    // 1.Replace this.props.date with this.state.date in the render() method:
    // 2.Add a class constructor that assigns the initial this.state:
    // 3.Remove the date prop from the <Clock /> element:
    // class Clock extends React.Component {
    //     //Note how to pass props to base constuctor
    //     constructor(props) {
    //         super(props);
    //             this.state = { date: new Date() };
    //         }

    //         render() {
    //             return (
    //                 <div>
    //                     <h1>Hello, world!</h1>
    //                     <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
    //                 </div>
    //             );
    //         }
    //     }

    // ReactDOM.render(
    //     <Clock />,
    //     document.getElementById('root')
    // );

    // Adding Lifecycle Methods to a class
    
    // We want to set up a timer whenever the Clock is rendered to the DOM for the first time. This is called “mounting” in React.
    // We also want to clear that timer whenever the DOM produced by the Clock is removed. This is called “unmounting” in React
    // there are to components mounts and unmounts
    // 1.componentDidMount()
    // The componentDidMount() method runs after the component output has been rendered to the DOM. This is a good place to set up a timer:
    // exam => componentDidMount() {
                //     this.timerID = setInterval(
                //         () => this.tick(),
                //         1000
                //     );
                // }
    // 2.componentWillUnmount() ==This method is called when a component is being removed from the DOM:
    //  componentWillUnmount() {
        //     clearInterval(this.timerID);
        // }
    // These methods are called 'Life cycle method'
    // It will use this.setState() to schedule updates to the component local state:

    // program for timer
        // class Clock extends React.Component {
        //     constructor(props) {
        //         super(props);
        //         this.state = { date: new Date() };
        //     }

        //     componentDidMount() {
        //         this.timerID = setInterval(
        //             () => this.tick(),
        //             1000
        //         );
        //     }

        //     componentWillUnmount() {
        //         clearInterval(this.timerID);
        //     }

        //     tick() {
        //         this.setState({
        //             date: new Date()
        //         });
        //     }

        //     render() {
        //         return (
        //             <div>
        //                 <h1>Hello, world!</h1>
        //                 <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
        //             </div>
        //         );
        //     }
        // }

        // ReactDOM.render(
        //     <Clock />,
        //     document.getElementById('root')
        // );
        // // et’s quickly recap what’s going on and the order in which the methods are called:
        // 1.When <Clock /> is passed to ReactDOM.render(), React calls the constructor of the Clock component. Since Clock needs to display the current time, it initializes this.state with an object including the current time. We will later update this state.
        // 2.React then calls the Clock component’s render() method. This is how React learns what should be displayed on the screen. React then updates the DOM to match the Clock’s render output.
        // 3.When the Clock output is inserted in the DOM, React calls the componentDidMount() lifecycle method. Inside it, the Clock component asks the browser to set up a timer to call the component’s tick() method once a second.
        // 4.Every second the browser calls the tick() method. Inside it, the Clock component schedules a UI update by calling setState() with an object containing the current time. Thanks to the setState() call, React knows the state has changed, and calls the render() method again to learn what should be on the screen. This time, this.state.date in the render() method will be different, and so the render output will include the updated time. React updates the DOM accordingly.
        // 5.If the Clock component is ever removed from the DOM, React calls the componentWillUnmount() lifecycle method so the timer is stopped.
    
        // DO STATE CORRECTLY
        // There are three things you should know about setState()
        // DO NOT MODIFY STATE DIRECTLY
        // The only place where you can assign this.state is the constructor.

        // Wrong way of setState
        // this.setState({
        //     counter : this.state.counter + this.props.increment
        // });
        
        // CORRECT WAY TO setState
        // To fix it, use a second form of setState() that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:
        // this.setState((state, props) => ({
        //     counter : state.counter + props.increment
        // }));

        // It also works for regular function
        // this.setState(function(state, props){
        //     return {
        //         counter : state.counter + props.increment
        //     }
        // });

        // STATE UPDATES ARE MERGED
        // or example, your state may contain several independent variables:
        // constructor(props) {
        //     super(props);
        //         this.state = {
        //             posts: [],
        //             comments: []
        //     };
        // }
        // Then you can update them independently with separate setState() calls:
        // componentDidMount() {
        //     fetchPosts().then(response => {
        //         this.setState({
        //             posts: response.posts
        //         });
        //     });

        //     fetchComments().then(response => {
        //         this.setState({
        //             comments: response.comments
        //         });
        //     });
        // }

        // HANDLING EVENTS
        // React elem is very similar to handling events on DOM
        // This method is called when a component is being removed from the DOM:
        // With JSX you pass a function as the event handler, rather than a string.
       
        // In HTML
        // <button onclick="activateLasers()">
        //         Activate Lasers
        // </button>

        // In React
        // <button onClick={activateLasers}>
        //     Activate Lasers
        // </button>

        // function ActionLink() {
        //     function handleClick(e) {
        //         e.preventDefault();
        //         console.log('The link was clicked.');
        //     }

        //     return (
        //         <a href="#" onClick={handleClick}>
        //             Click me
        //         </a>
        //     );
        // }

        // If you aren’t using class fields syntax, you can use an arrow function in the callback:

        class LoginButton extends React.Component{
            handleClick = (e) => {
                let count = e
                console.log(count)
                console.log('This is:', this)
            }
            render () {
                return (
                    // we can also pass the event (e)
                    // <button onClick={(e) => {this.handleClick(e)}}>Click Me</button>

                    // PAASING ARGUMENTS TO EVENT HANDLERS
                    <button value="btnAdd" onClick={(e) => {this.handleClick(e.target.value)}}>ClickMe</button>
                )
            }
        }

        // CONDOTIONAL RENDERING
        // you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application.
        // Example
        // function UserGreeting(props){
        //     return <h1>Welcome back!</h1>
        // }
        // function GuestGreeting(props){
        //     return <h1>Please sign up</h1>
        // }

        // we want to display either component based on user loggedin
        // function Greeting(props){
        //     const isLoggedIn = props.isLoggedIn
        //     if(isLoggedIn) {
        //         return <UserGreeting />
        //     }
        //     return <GuestGreeting />
        // }
        
        // Next Example
        // function LoginButton (props){
        //     return (
        //         <button onClick={props.OnClick}>Login</button>
        //     );
        // }
        // function LogoutButton (props){
        //     return (
        //         <button onClick={props.OnClick}>Logout</button>
        //     );
        // }


        ReactDOM.render(<Greeting isLoggedIn={true} />, document.getElementById('root'))
    </script>
</body>

</html>